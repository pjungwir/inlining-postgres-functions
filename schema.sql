DROP TABLE IF EXISTS users CASCADE;
DROP TABLE IF EXISTS companies CASCADE;
DROP TABLE IF EXISTS memberships CASCADE;
DROP TABLE IF EXISTS sales CASCADE;
DROP TABLE IF EXISTS line_items CASCADE;
DROP EXTENSION IF EXISTS commission_cents CASCADE;

CREATE TABLE users (
  id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL
);
CREATE TABLE companies (
  id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL
);
CREATE TABLE memberships (
  id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id INTEGER NOT NULL REFERENCES users (id),
  company_id INTEGER NOT NULL REFERENCES companies (id),
  commission_percent FLOAT NOT NULL DEFAULT 0
);
CREATE UNIQUE INDEX idx_memberships_user_company ON memberships (user_id, company_id);
CREATE UNIQUE INDEX idx_memberships_company_user ON memberships (company_id, user_id);
CREATE TABLE sales (
  id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  vendor_id INTEGER NOT NULL REFERENCES companies (id),
  po_number TEXT NOT NULL,
  total_price_cents INTEGER NOT NULL,
  salesperson_id INTEGER REFERENCES users (id),
  sold_at TIMESTAMP WITH TIME ZONE NOT NULL,
  CONSTRAINT uq_sales_po_number UNIQUE (vendor_id, po_number)
);
CREATE TABLE line_items (
  id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  sale_id INTEGER NOT NULL REFERENCES sales (id),
  sku TEXT NOT NULL,
  price_cents INTEGER NOT NULL
);
-- CREATE UNIQUE INDEX idx_line_items_sale_id ON line_items (sale_id, sku);

/* Gets the sales visible to the given user */
CREATE OR REPLACE FUNCTION visible_sales(user_id INT)
RETURNS SETOF sales
AS $$
  SELECT * FROM sales
  WHERE vendor_id IN (SELECT company_id
                      FROM   memberships
                      WHERE  user_id = $1);
$$ LANGUAGE sql STABLE;

/* Gets the sales visible to the given user */
CREATE OR REPLACE FUNCTION visible_sales_slow(user_id INT)
RETURNS SETOF sales
AS $$
  SELECT * FROM sales
  WHERE vendor_id IN (SELECT company_id
                      FROM   memberships
                      WHERE  user_id = $1);
$$ LANGUAGE sql;

/* Gets sale ids visible to the given user */
CREATE OR REPLACE FUNCTION visible_sale_ids(user_id INT)
RETURNS SETOF INTEGER
AS $$
  SELECT id FROM sales
  WHERE vendor_id IN (SELECT company_id
                      FROM   memberships
                      WHERE  user_id = $1);
$$ LANGUAGE sql STABLE;

CREATE EXTENSION commission_cents;
CREATE OR REPLACE FUNCTION commission_cents_support(INTERNAL)
RETURNS INTERNAL
AS 'commission_cents', 'commission_cents_support'
LANGUAGE C;

CREATE OR REPLACE FUNCTION commission_cents(_sale_id INTEGER, _salesperson_id INTEGER)
RETURNS INTEGER
AS $$
  SELECT  total_price_cents * COALESCE(commission_percent, 0)
  FROM    sales AS s
  LEFT JOIN memberships AS m
  ON      m.company_id = s.vendor_id
  AND     m.user_id = _salesperson_id
  WHERE   s.id = _sale_id;
$$
LANGUAGE sql STABLE SUPPORT commission_cents_support;

CREATE OR REPLACE FUNCTION start_of_month(d DATE)
RETURNS DATE
AS $$
-- Feels like a timezone bug here:
SELECT date_trunc('month', d)::date;
$$ LANGUAGE sql IMMUTABLE;

CREATE OR REPLACE FUNCTION end_of_month(d DATE)
RETURNS DATE
AS $$
-- Feels like a timezone bug here:
SELECT date_trunc('month', d)::date;
$$ LANGUAGE sql IMMUTABLE;

CREATE OR REPLACE FUNCTION monthly_commission_for_salesperson(_salesperson_id INTEGER, d DATE)
RETURNS INTEGER
AS $$
SELECT  commission_cents(id, $1)
FROM    sales
WHERE   salesperson_id IS NOT DISTINCT FROM $1
AND     sold_at BETWEEN start_of_month($2) AND end_of_month($2);
$$ LANGUAGE sql STABLE;

/*
INSERT INTO users VALUES (1, 'Paul');
INSERT INTO users VALUES (2, 'Jimmy');
INSERT INTO companies VALUES (1, 'PaulCo');
INSERT INTO companies VALUES (2, 'AnotherCo');
INSERT INTO companies VALUES (3, 'PrivateCo');
INSERT INTO memberships VALUES (1, 1, 1);
INSERT INTO memberships VALUES (2, 1, 2);
INSERT INTO memberships VALUES (3, 2, 1);
INSERT INTO sales VALUES (1, 1, '0001', 500, NULL);
INSERT INTO sales VALUES (2, 2, '0001', 750, NULL);
INSERT INTO sales VALUES (3, 3, '0001', 999, NULL);

INSERT INTO line_items VALUES (1, 1, 'ABC', 500);
INSERT INTO line_items VALUES (2, 2, 'ABC', 500);
INSERT INTO line_items VALUES (3, 2, 'MMM', 250);
INSERT INTO line_items VALUES (4, 3, 'XYZ', 999);
*/

\set max_companies 10000
\set max_users 50000
\set max_memberships_per_user 5
\set max_sales_per_company 10000
\set max_line_items_per_sale 20

WITH
lows AS (SELECT chr(i) AS a FROM generate_series(97, 122) AS s(i)),
ups AS (SELECT chr(i) AS a FROM generate_series(65, 90) AS s(i))
INSERT INTO companies (name)
SELECT CONCAT(ups.a, l1.a, l2.a, l3.a, l4.a, ' Inc')
FROM ups
CROSS JOIN lows AS l1
CROSS JOIN lows AS l2
CROSS JOIN lows AS l3
CROSS JOIN lows AS l4
LIMIT :max_companies;

WITH
lows AS (SELECT chr(i) AS a FROM generate_series(97, 122) AS s(i)),
ups AS (SELECT chr(i) AS a FROM generate_series(65, 90) AS s(i))
INSERT INTO users (name)
SELECT CONCAT(ups.a, l1.a, l2.a, l3.a, l4.a, l5.a)
FROM ups
CROSS JOIN lows AS l1
CROSS JOIN lows AS l2
CROSS JOIN lows AS l3
CROSS JOIN lows AS l4
CROSS JOIN lows AS l5
LIMIT :max_users;

-- Give each user at least one membership:
INSERT INTO memberships (company_id, user_id, commission_percent)
SELECT  (u.id + i) % :max_companies + 1, u.id, 0.1
FROM    users AS u
JOIN LATERAL generate_series(0, u.id % :max_memberships_per_user) AS s(i)
ON true
;
-- Give user 1 a lot of memberships:
INSERT INTO memberships (company_id, user_id, commission_percent)
SELECT  id, 1, 0.2
FROM    companies
WHERE   id > 2 AND id % 2 = 0;

-- Power law: companies with a lower id sell more.
INSERT INTO sales (vendor_id, po_number, total_price_cents, salesperson_id, sold_at)
SELECT  c.id, i::text, 0, null, now()
FROM    companies AS c
JOIN LATERAL generate_series(1, 1 + (:max_sales_per_company - 1) / c.id) AS s(i)
ON true
;

-- Weak power law, with shuffled x (TODO: the shuffling)
INSERT INTO line_items (sale_id, sku, price_cents)
SELECT  id, 'TODO', 10000
FROM    sales
JOIN LATERAL generate_series(1, 1 + (:max_line_items_per_sale - 1) / id) AS s(i)
ON true
;

-- Give credit to salespeople for some sales, but not all:
UPDATE  sales AS s
SET     salesperson_id = (
  SELECT  m.user_id
  FROM    memberships m
  WHERE   m.company_id = s.vendor_id
  AND     m.user_id % 3 = s.id % 3
  AND     s.id % 10 <> 0
  ORDER BY m.user_id
  LIMIT 1
)
;

-- Compute the total price:
WITH summed_line_items AS (
  SELECT  sale_id, SUM(price_cents) AS total_price_cents
  FROM    line_items
  GROUP BY sale_id
)
UPDATE  sales AS s
SET     total_price_cents = lis.total_price_cents
FROM    summed_line_items AS lis
WHERE   lis.sale_id = s.id
;

VACUUM ANALYZE;
